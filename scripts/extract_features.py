import csv, errno, os, sqlite3, time
from malware_classifier.parsing.exe import ExeAsmSample, ExeHexSample

###############################################################################

# The list of all associated feature methods paired with the folder the 
# features file should be stored in. Used by the extract_features function.
hex_features = [('1-Gram',      ExeHexSample.one_gram_features),
                ('Metadata',    ExeHexSample.metadata_features),
                ('Entropy',     ExeHexSample.entropy_features),
                ('Image',       ExeHexSample.image_features),
                ('String',      ExeHexSample.string_features)]
                
asm_features = [('Metadata',    ExeAsmSample.metadata_features),
                ('Symbol',      ExeAsmSample.symbol_features),
                ('Opcode',      ExeAsmSample.opcode_features),
                ('Register',    ExeAsmSample.register_features),
                ('API',         ExeAsmSample.api_features),
                ('Section',     ExeAsmSample.section_features),
                ('Data Define', ExeAsmSample.data_define_features),
                ('Misc',        ExeAsmSample.misc_features)]

# The list of all column names for the feature columns for the Sample table in 
# the database. Used when creating the database.
feature_columns = ['[1-Gram]', '[Hex Metadata]', '[Entropy]', '[Image]', 
                   '[String]', '[Asm Metadata]', '[Symbol]', '[Opcode]',
                   '[Register]', '[API]', '[Section]', '[Data Define]', 
                   '[Misc]']
                
###############################################################################

def create_dirs(file_path):
    """Create any directories needed for the specified file.
    
    If the directories already exists for the file, this will do nothing.
    """
    
    # Retrieve the directory for the file.
    directory = os.path.dirname(file_path)
    
    # Ensure the directory does not exist.
    if (os.path.isdir(directory)):
        return
        
    # Create the directory.
    try:
        os.makedirs(directory)
        
    # NOTE: It is possible that a race condition can allow the directory to be
    #       created in between checking if the directory exists and attempting 
    #       to make the directory. If this happens, an error will be thrown.
    except OSError as e:
        
        # If the error was not due to the directory already existing, something
        # else happened.
        if (e.errno != errno.EEXIST):
            raise

def extract_features(sample_name, sample_directory, database_connection, 
                     database_directory):
    """Extract all of the features from the sample with the given name whose
    files can be found in the given directory and store them using the given
    database connection.
    
    All of the features will be stored in a subfolder called 'features' in
    the database's directory.
    """
            
    # Create sample objects for both the hex and assembly files.
    hex_path = os.path.join(sample_directory, ('%s.bytes' % sample_name))
    asm_path = os.path.join(sample_directory, ('%s.asm' % sample_name))
    
    hex_sample = ExeHexSample(hex_path)
    asm_sample = ExeAsmSample(asm_path)
    
    # Perform any optimizations.
    asm_sample.optimize()
    
    # Save all of the features extracted for each category into a .csv file
    # whose name is the name of the sample. Each feature category will have
    # its own subdirectory inside the features directory that will hold all
    # of the feature files for each sample. We will keep track of relative
    # paths for each of these files in order to insert them into the database
    # later.
    feature_paths = []
    
    # Hex Features
    for feature in hex_features:
        
        # Each feature is a tuple. The first value of the tuple is the name
        # of the folder for the feature category and the second value is the
        # method to call in the ExeHexSample class to obtain the features.
        feature_folder = feature[0]
        feature_method = feature[1]
        
        # Construct the path for the feature file.
        feature_file_path = 'features/Hex/{0}/{1}.csv'.format(feature_folder,
                                                              sample_name)
        feature_paths.append(feature_file_path)
        
        # Retrieve the features from the sample and store them in the feature
        # file.
        features = feature_method(hex_sample)
        
        save_features(features, os.path.join(database_directory, 
                                             feature_file_path))
        
    # Asm Features
    for feature in asm_features:
        
        feature_folder = feature[0]
        feature_method = feature[1]
        
        feature_file_path = 'features/Asm/{0}/{1}.csv'.format(feature_folder,
                                                              sample_name)
        feature_paths.append(feature_file_path)
                                                              
        features = feature_method(asm_sample)
        save_features(features, os.path.join(database_directory, 
                                             feature_file_path))
    
    # Construct the query for inserting a row in the Samples table. The row
    # should be formatted like so:
    #
    #   {Sample Name} {Label} {Feature File Path 1} {Feature File Path 2} ...
    #
    # NOTE: Since we have no way of knowing the label currently, it will be
    #       entered with a blank value. The labels should be added later.
    query = 'INSERT OR REPLACE INTO Samples VALUES (?,NULL,'
    query += ','.join('?' for path in feature_paths)
    query += ')'
    
    # Execute the query.
    args = [sample_name] + feature_paths
    database_connection.execute(query, args)
    
    # Commit the change to the database.
    database_connection.commit()

def get_sample_names(directory):
    """Return all of the samples in the specified directory.
    
    A sample is considered in the directory if there exists both a .bytes file
    and a .asm file with the sample's name.
    
    The list returned will contain only the names of all of the samples. The
    names will not contain file extensions or the directory.
    
    The list will be sorted alphabetically.
    """
    
    # Retrieve all of the files in the directory.
    files = set(os.listdir(directory))
    
    # Each sample should have 1) a .bytes file and 2) a .asm file. Both files
    # should have the same name minus the extension. This name should be the md5
    # hash that is used to uniquely identify the file. In order to retrieve all
    # of the potential hashes in the directory, we can remove all of the file
    # extensions and filter out duplicate names.
    names = set(os.path.splitext(file)[0] for file in files)
    
    # Ensure each unique name has both an associated .bytes and associated
    # .asm file.
    names = list(name for name in names if ('%s.bytes' % name) in files 
                                        and ('%s.asm' % name) in files)
    
    # Sort the names alphabetically.
    names.sort()
    
    return names
    
def log(message, file=None):
    """Write the specified log message to the specified file.
    
    The file should be an already opened file object with write permission.
    
    On top of being written to the file, the message will also be displayed in
    the console.
    """
    
    # Print the message to stdout.
    print(message)
    
    # Write the message to the log file.
    if file:
        file.write(message + '\n')
    
def open_sample_database(database_name):
    """Returns connection to the specified database.
    
    The database will be guaranteed to have a table called 'Samples'. That
    means that if the database does not already contain this table, it will
    be created in the opened database.
    
    If the database pointed to by the path does not exist, it will be created.
    """
    
    # Create a connection to the database. This will create the database file
    # if it doesn't already exist.
    connection = sqlite3.connect(database_name)
    
    # Create the Samples table if it doesn't already exist.
    query = '''CREATE TABLE IF NOT EXISTS Samples 
               ( 
                   Hash  TEXT PRIMARY KEY,
                   Label INTEGER,'''
    query += ','.join('%s text' % column for column in feature_columns)
    query += ''')'''
                   
    connection.execute(query)
    connection.commit()
    
    return connection
                      
def save_features(features, file_name):
    """Save the specified features in the file with the specified name.
    
    The file will be formatted as a .csv (Comma Separated Values) file.
    """
    
    # Ensure the directories for the file name exist.
    create_dirs(file_name)
    
    # Save the features into the file in the csv format.
    with open(file_name, 'w') as file:
        writer = csv.writer(file)
        writer.writerow(features)

###############################################################################
#                                 MAIN                                        #
###############################################################################

# Retrieve any option arguments.
options = set()
for arg in os.sys.argv:
    if (arg.startswith('-')):
        os.sys.argv.remove(arg)
        options |= set(char for char in arg.strip('-'))

allow_repeats = 'r' in options
        
# Ensure the user input a directory and database.
if (not 4 >= len(os.sys.argv) >= 3):
    print('\n\tUsage: extract_features.py [Sample Directory] ' +
          '[Samples Database] [Optional: Log File]\n')
    os.sys.exit(1)
    
directory = os.sys.argv[1]
database = os.sys.argv[2]

# Open the log file if the user supplied one.
if (len(os.sys.argv) == 4):
    log_file_name = os.sys.argv[3]
    create_dirs(log_file_name)
    log_file = open(log_file_name, 'a')
    
else:
    log_file = None

# Grab the directory for the database.
database_directory = os.path.dirname(database)
    
# Ensure the directory exists.
if (not os.path.isdir(directory)):
    print('''\n\tCould not find the directory: %s\n''' % directory)
    os.sys.exit(1)
    
# Clear the console.
os.system('cls')

# Log the current time.
if (log_file):
    log_file.write('\n---------------------------------------------------------\n')
    log_file.write('extract_features.py Execution %s\n\n' \
                   % time.strftime('%H:%M:%S'))
    
# Retrieve the names of all of the samples in the directory.
names = get_sample_names(directory)

log_names = 'Found the following samples in %s directory:\n' % directory
log_names += ''.join('\t%s\n' % name for name in names)
log(log_names, log_file) 

# Retrieve a connection to the passed samples database.
connection = open_sample_database(database)

log_connection = 'Successfully connected to %s database\n' % database
log(log_connection, log_file)

# Filter out any sample names the database already contains unless repeat
# samples are allowed.
if (not allow_repeats):
    
    # Retrieve a list of all of the samples in the database.
    cursor = connection.cursor()
    cursor.execute('SELECT Hash FROM Samples')
    
    existing_samples = set(str(row[0]) for row in cursor.fetchall())
        
    # Filter out repeat samples.
    repeat_samples = set(name for name in names if name in existing_samples)            
    names = [name for name in names if name not in repeat_samples]
            
    # Log repeats.
    if (repeat_samples):
        log_repeats = 'Ignoring samples already in database (use -r option ' +\
                      'to allow repeat samples):\n'
        log_repeats += ''.join('\t%s\n' % sample for sample in repeat_samples)
        log(log_repeats, log_file)

# Keep track of which samples are extracted successfully and which ones failed.
successes = []
failures = []

# Keep track of extraction time
extraction_time = 0

# Extract the features from all of the samples found.
for sample_name in names:

    try:
        # Keep track of how long it takes to extract from the sample.
        log('Extracting features from %s...' % sample_name, log_file)    
        start = time.clock()
        
        extract_features(sample_name, directory, connection, database_directory)
        
        # Report the time it took to extract the features.
        end = time.clock()
        log(('Successfully extracted from {0}'
             'in {1} seconds\n').format(sample_name, end - start), log_file)
             
        # Count sample as success.
        successes.append(sample_name)
             
    except Exception as e:
        end = time.clock()
        
        # Count the sample as a failure.
        log('Error extracting from {0}: {1}\n'.format(sample_name, str(e)), 
            log_file)
        failures.append(sample_name)
        
    finally:
        # Add to the extraction time.
        extraction_time += end - start
        
# Close the connection to the database.
connection.close()

# Log the successes and failures.
if (successes):
    log_success = 'Successfully extracted features from:\n'
    log_success += ''.join('\t%s\n' % name for name in successes)
    log(log_success, log_file)

if (failures):
    log_failures = 'Failed to extract features from:\n'
    log_failures += ''.join('\t%s\n' % name for name in failures)
    log(log_failures, log_file)
    
# Log the total extraction time.
log('Total Extraction Time: %s seconds\n' % extraction_time, log_file)

# Log the end of the execution.
if (log_file):
    log_file.write('\n---------END OF extract_features.py EXECUTION----------\n\n')

    # Close the log file.
    log_file.close()