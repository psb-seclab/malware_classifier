from os.path import getsize
from math import log
import numpy as np

def entropy(counts, window_size):
    """Retrieve the entropy for a window with the specified counts and window
    sizes.
    
    The counts should be a list of the counts for each of the distinct items
    in the window.
    
    The return value will be between 0 (order) and 8(randomness).
    """
    
    entropies = [count / window_size * log(count / window_size, 2) for count 
                 in counts if count > 0]
    
    return -sum(entropies)
    
class ExeSample(object):
    """An ExeSample represents a malware sample.
    
    Every malware sample must contain a hexadecimal dump. With that provided,
    the sample can be analyzed and have various features extracted from it.
    """
    
    def __init__(self, hex_file_name):
        """Initialize a new ExeSample whose hex dump can be found in the file
        pointed to by hex_file_name.
        """
        
        self.hex_file_name = hex_file_name
        
        # Ensure the hex file is valid.
        try:
            with open(hex_file_name, "rb") as file:
                # Store the contents of the file for parsing.
                self._hex_contents = file.read()
            
        except IOError:
            raise ValueError('Invalid file name: %s' % hex_file_name)
            
    def asm_api(self):
        """Retrieve the frequency of the top 794 most frequent APIs used in 
        malicious files in list form.
        
        Each element of this list will show how many of each API is used.
        
        Files containing no APIs are highly suspicious.
        """
        
        api_list = [line.rstrip('\n') for line in open('api.txt')]
        
        lines = self._hex_contents.split(b'\n')
        
        counts = {key: 0 for key in api_list}
        for i in api_list:
            for j in lines:
                if bytes(i, 'utf-8') in j:
                    counts[i] = counts.get(i, 0) + 1
        return counts.values()
                
        
    def asm_misc(self):
        
        misc_list = [line.rstrip('\n') for line in open('misc.txt')]
        
        lines = self._hex_contents.split(b'\n')
        
        counts = {key: 0 for key in misc_list}
        for i in misc_list:
            for j in lines:
                if bytes(i, 'utf-8') in j:
                    counts[i] = counts.get(i, 0) + 1
        return counts.values()
        
    def hex_bytes(self):
        """Return a list of all bytes contained in the hex file for the sample.
        
        The first time this functions is called, the bytes are parsed from the
        file and cached. Subsequent calls simply return the cache.
        
        NOTE: The ?? bytes are not filtered in this function.
        """
        
        # Parse the hex bytes from the file if they have not been parsed yet.
        if not hasattr(self, '_hex_bytes'):
            
            # Every two hex digits represents a single byte.
            contents = ''.join(self._hex_contents.split())
            self._hex_bytes = [contents[i:i+2] for i 
                               in range(0, len(contents), 2)]
                    
        return self._hex_bytes
        
    def hex_entropies(self, window_size=10000):
        """Calculate the entropy values for each of the windows in the hex
        file if the window has the specified size.
        
        A list of all of the entropy values calculated for each window will
        be returned.
        """
        
        hex_bytes = self.hex_bytes()
        
        # Ensure there are enough bytes for at least one window.
        if (len(hex_bytes) < window_size):
            raise ValueError(('The window size {0} exceeds the number ' +
                             'of bytes in the file: {1}')
                             .format(window_size, len(hex_bytes)))
                             
        # Retrieve the byte counts for the first window.
        window = hex_bytes[:window_size]
        
        byte_counts = dict()
        for byte in window:
            byte_counts[byte] = byte_counts.get(byte, 0) + 1
        
        # Calculate the entropy for the first window.
        entropies = [ entropy(byte_counts.values(), window_size) ]
        
        # Add the entropy values for the rest of the windows.
        for i in range(1, len(hex_bytes) - window_size):
            
            # Adjust the window count by removing from the count of the byte
            # that just got removed and adding to the count of the byte that
            # just got added.
            removed_byte = hex_bytes[i - 1]
            if (byte_counts.get(removed_byte, 0) != 0):
                byte_counts[removed_byte] -= 1
            
            added_byte = hex_bytes[i + window_size]
            byte_counts[added_byte] = byte_counts.get(added_byte, 0) + 1
            
            # Calculate the entropy for the current window's count.
            entropies.append(entropy(byte_counts.values(), window_size))
        
        return entropies
        
    def hex_entropy_stats(self, window_size=10000):
        """Retrieves statistics for the entropy values collected from the
        hex file.
        
        The list of stats returned are in the following format:
        
            [ { mean }, { variance }, { standard deviation }, 
              { Percentiles 0 - 100 } ]
        """
        
        # Retrieve the list of entropy values.
        entropies = self.hex_entropies(window_size)
        
        # Calculate various statistics for the entropy values.
        stats = [
            np.mean(entropies),
            np.var(entropies),
            np.std(entropies),
        ]
        
        # Percentiles 0 - 100
        for i in range(101):
            stats.append(np.percentile(entropies, i))
            
        return stats
        
                
    def hex_features(self):
        """Return a feature vector containing all of the features retrieved 
        from the hex file of the sample.
        
        The format of the feature vector is as follows (the numbers in
        parenthesis indicate how many features are in each section):
        
        [ { 1-gram frequencies (256) }, { hex file metadata (2) }, 
          { hex file entropy (105) }, { string length distribution (116) } ]
        """
        
        features = []
        
        features += self.hex_one_gram_frequencies()
        features += self.hex_metadata_features()
        features += self.hex_entropy_stats()
        features += self.hex_entropies(len(self.hex_bytes()))
        features += self.hex_string_length_counts(4, 120)
        
        return features
        
    def hex_file_size(self):
        """Return the size of the hex dump file in bytes."""
        return getsize(self.hex_file_name)
        
    def hex_first_address(self):
        """Return the address of the first byte sequence in the sample's
        hex file.
        """
        
        # The first word in the hex file is the address of the first byte 
        # sequence.
        first_word = self._hex_contents.split()[0]
        
        # The address is a hexadecimal value. Convert it to decimal.
        return int(first_word, 16)
            
    def hex_metadata_features(self):
        """Return a feature vector containing metadata related features
        extracted from the sample's hex dump.
        
        The feature vector will have the following format:
        
        [ {file size (bytes)}, {1st byte sequence address (decimal)} ]
        """
        return [self.hex_file_size(), self.hex_first_address()]
        
    def hex_string_length_counts(self, min, max):
        """Return a list of counts for all of the string lengths in the range
        of min - max (inclusive) characters.
        """
        
        # Retrieve all of the bytes in the hex file.
        bytes = self.hex_bytes()
        
        # The first four bytes of every 20 bytes contains an address, which
        # should not be analyzed to find a string.
        bytes = [bytes[i] for i in range(len(bytes)) if i % 20 >= 4]
        
        # Conver the hex values to decimal values.
        # NOTE: The ?? bytes are useless. Filter them out.
        ascii_values = [int(byte, 16) for byte in bytes if byte != '??']
        
        # The printable range for ASCII characters is 32 - 127. Replace
        # anything outside those bounds with a null to be filtered out.
        characters = [chr(value) if 32 <= value <= 127 else '\0' for value 
                      in ascii_values]
                                              
        # Retrieve each string by splitting up sequences of characters by
        # null characters.
        strings = ''.join(characters)
        strings = strings.split('\0')
        
        # Retrieve the length of each string.
        string_lengths = [len(string) for string in strings]
        
        # Record the requested counts.
        return [string_lengths.count(i) for i in range(min, max+1)]
        
    def hex_one_gram_frequencies(self, *one_grams):
        """Return the list of frequencies in the hex file for every specified
        1-gram value.
        
        A 1-gram has 256 possible values (0 - 255). The list returned will
        contain integer values representing the number of times its respective
        1-gram appeared in the file.
        
        If no argument is specified, the frequencies of all 256 possible 
        1-grams are found. In this scenario, the 1-grams are in ascending 
        order, meaning that 0x00 is at index 0 and 0xFF is at index 255.
        """
        
        # Every two hex digits represents one byte, which represents a 1-gram.
        # Remove the whitespace in the file and retrieve all of the possible
        # 1-grams.
        file_one_grams = [int(byte, 16) for byte in self.hex_bytes() 
                          if byte != '??']

        if not one_grams:
            one_grams = range(256)
        
        # Find the frequency of every passed 1-gram.
        frequencies = []
        
        for one_gram in one_grams:
            # Make sure the 1-gram is an integer.
            if not isinstance(one_gram, int):
                raise TypeError('Passed value must be an integer')
            
            # Make sure the 1-gram is in the correct range.
            if not (0 <= one_gram <= 255):
                raise ValueError('The value %s is not in the range 0 - 255' 
                                 % one_gram)
        
            # Count the frequency.
            frequencies.append(file_one_grams.count(one_gram))
        
        # Return the frequency of the specified 1-gram in the file.
        return frequencies