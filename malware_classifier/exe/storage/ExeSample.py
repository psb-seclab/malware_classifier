from abc import ABCMeta, abstractmethod
from math import log

from ...storage import Sample, feature

###############################################################################

def entropy(counts, window_size):
    """Retrieve the entropy for a window with the specified counts and window
    sizes.
    
    The counts should be a list of the counts for each of the distinct items
    in the window.
    
    The return value will be between 0 (order) and 8 (randomness).
    
    This is the standard function that should be used to calculate entropy in
    all ExeSample implementations in order to keep consistency.
    """
    
    entropies = [float(count) / float(window_size) * \
                 log(float(count) / float(window_size), 2) 
                 for count in counts if count > 0]
    
    return -sum(entropies)

###############################################################################

class ExeSample(Sample):
    """ExeSample is the base class that defines all of the features a Windows
    Executable sample should contain.
    
    ExeSample is abstract and does not implement any of the feature methods
    defined in it. The purpose of this class is to provide a universal set
    of features that should be parsed from any format of a Windows Executable
    (i.e. Binary files, disassembled files, etc.).
    """
    
    __metaclass__ = ABCMeta
    
    ###########################################################################
    
    @staticmethod
    def instruction_list():
        """Get the list of mnemonics for all of the instructions to be used
        in features involving specific specific instructions.
        """
        
        return [b'add', b'al', b'bt', b'call', b'cdq', b'cld', b'cli', b'cmc', 
                b'cmp', b'const', b'cwd', b'daa', b'.byte', b'dec', b'endp', 
                b'ends', b'faddp', b'fchs', b'fdiv', b'fdivp', b'fdivr', 
                b'fild', b'fistp', b'fld', b'fstcw', b'fstcwimul', b'fstp', 
                b'fword', b'fxch', b'imul', b'in', b'inc', b'ins', b'int3', 
                b'jb', b'je', b'jg', b'jge', b'jl', b'jmp', b'jnb', b'jno', 
                b'jnz', b'jo', b'jz', b'lea', b'loope', b'mov', b'movzx', 
                b'mul', b'near', b'neg', b'not', b'or', b'out', b'outs', 
                b'pop', b'popf', b'proc', b'push', b'pushf', b'rcl', b'rcr', 
                b'rdtsc', b'rep', b'ret', b'retn', b'rol', b'ror', b'sal', 
                b'sar', b'sbb', b'scas', b'setb', b'setle', b'setnle', 
                b'setnz', b'setz', b'shl', b'shld', b'shr', b'sidt', b'stc', 
                b'std', b'sti', b'stos', b'sub', b'test', b'wait', b'xchg', 
                b'xor']
                
    @staticmethod
    def register_list():
        """Get the list of all registers to be used for features involving
        specific registers.
        """
        
        return [b'edx', b'esi', b'es', b'fs', b'ds', b'ss', b'gs', b'cs', 
                b'ah', b'al', b'ax', b'bh', b'bl', b'bx', b'ch', b'cl', b'cx', 
                b'dh', b'dl', b'dx', b'eax', b'ebp', b'ebx', b'ecx', b'edi', 
                b'esp']
    
    @staticmethod
    def symbol_list():
        """Get the list of all symbols to be used for features involving
        specific symbols.
        
        Only one bracket is present since its paired bracket is the same count.
        """
        
        return [b'+', b'-', b'*', b'[']
    
    @staticmethod
    def section_list():
        """Get the list of all of the section names to be used for features
        involving specific sections.
        """
        
        return ['.bss', '.data', '.edata', '.idata', '.rdata', '.rsrc', 
                '.text', '.tls', '.reloc']
    
    ###########################################################################
    
    @abstractmethod
    @feature('Byte Count')
    def byte_count(self):
        """Extract the number of bytes that are in the code section of the
        executable.
        
        This should not include addresses.
        
        Total number of features: 1
        """
        return self.byte_count()
        
    @abstractmethod
    @feature('Entropy')
    def entropy(self):
        """Extract the entropy of all of the bytes in the code section of the
        executable.
        
        Address bytes should not be included in the bytes used to calculate
        the entropy.
        
        Total number of features: 1
        """
        return self.entropy()
        
    @abstractmethod
    @feature('Entropy Stats')
    def entropy_stats(self):
        """Extract various statistics about the set of entropy values
        retrieved from the bytes in the code section of the executable. 
        
        The entropy values should be retrieved via the sliding window method
        using a window size of 10000. The addresses should not be included
        in the list of bytes.
        
        The following statistics should be retrieved from the distribution of
        entripy values and returned in a list (in the specified order):
        
            - Mean
            - Variance
            - Percentiles 0 - 100   
            
        Total number of features: 103
        """
        return self.entropy_stats()
    
    @abstractmethod
    @feature('First Address')
    def first_address(self):
        """Extract the address of the first code instruction in the executable
        binary.
        
        This should be formatted as a base 10 integer value.
        
        Total number of features: 1
        """
        return self.first_address()
        
    @abstractmethod
    @feature('Haralick Features')
    def haralick_features(self):
        """Extract the Haralick Features from an image constructed out of the
        grayscale pixels constructed from each of the hex digits in the code
        section of the executable.
        
        The features should be returned as a list.
        
        Total number of features: 52
        """
        return self.haralick_features()
        
    @abstractmethod
    @feature('Instruction Counts')
    def instruction_counts(self):
        """Extract the count of each of the instructions with the mnemonics
        that are returned by the static method instruction_list. 
        
        This should return a list of counts that corresponds with the values
        returned by instruction_list.
        
        Total number of features: 91
        """
        return self.instruction_counts()
    
    @abstractmethod
    @feature('Instruction Total')
    def instruction_total(self):
        """Extract the total number of the instructions that are returned 
        by the static method instruction_list.
        
        This should return a base-10 integer value.
        
        Total number of features: 1
        
        """
        return self.instruction_total()
        
    @abstractmethod
    @feature('Local Binary Patterns')
    def local_binary_patterns(self):
        """Extract the local binary pattern features from an image constructed
        out of the grayscale pixels constructed from each of the hex digits in
        the code section of the executable.
        
        Total number of features: 108
        """
        return self.local_binary_patterns()
    
    @abstractmethod
    @feature('1-Gram Frequencies')
    def one_gram_frequencies(self):
        """Extract the number of occurrences of all 256 possible bytes values
        (00 - FF) in the hex representation of the executable binary. This
        should not include any addresses.
        
        The return value should be a list of all of the frequencies in
        ascending order of the byte values they represent (starting with 00,
        ending with FF).
        
        Total number of features: 256
        """
        return self.one_gram_frequencies()
        
    @abstractmethod
    @feature('Registers')
    def register_counts(self):
        """Extract the count of register usages for each of the registers
        returned by the static register_list method.
        
        The returned value should be a list containing the counts
        corresponding to the list of registers.
        """
        return self.register_counts()
        
    @abstractmethod
    @feature('Section Sizes')
    def section_sizes(self):
        """Extract the size of each of the sections defined in the static
        section_list property.
        
        This should return a list of sizes that corresponds with the list of
        sections. Each size should be the number of bytes in the section.
        
        Total number of features: 9
        """
        return self.section_sizes()
        
    @abstractmethod
    @feature('String Lengths')
    def string_lengths(self):
        """Extract the numbers of strings in the code section of the executable
        that fit into various bins of string lengths. 
        
        The count of strings in the following bins should be returned in a
        list:
        
            (0, 10], 
            (10, 30], 
            (30, 60], 
            (60, 90], 
            (0, 100],
            (100, 150], 
            (150, 250], 
            (250, 400], 
            (400, 600], 
            (600, 900],
            (900, 1300],
            (1300, 2000], 
            (2000, 3000], 
            (3000, 6000], 
            (6000, 150000]
            (150000+)
            
        Total number of features: 16
        """
        return self.string_lengths()
    
    @abstractmethod
    @feature('Symbol Counts')
    def symbol_counts(self):
        """Extract the number of symbols in the op string.
        
        This should return a list of counts that corresponds with the list
        of symbols.
        
        Total number of features: 4
        """
        
        return self.symbol_counts()
        
    @abstractmethod
    #@feature('2-Gram Frequencies')
    def two_gram_frequencies(self):
        """Extract the number of occurrences of all 65,536 possible 2-gram
        values (0000 - FFFF) in the hex representation of the binary. This
        should not include any addresses.
        
        The return value shoud be a list of all of the frequencies in ascending
        order of the byte values they represent (starting with 0000, ending 
        with FFFF).
        
        Total number of features: 65,536
        """
        return self.two_gram_frequencies()
