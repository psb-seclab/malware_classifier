from abc import abstractmethod
from malware_classifier.exe.storage import ExeSample, entropy
from malware_classifier.parsing import memoize
from malware_classifier.storage import feature
from math import log

import mahotas
import numpy as np

###############################################################################

class ExeSampleBase(ExeSample):
    """ExeSampleBase is a base implementation of the ExeSample interface that
    implements the main logic for many of the defined feature methods.
    
    ExeSampleBase is designed to use a specific format that is reasonably
    abstract so that subclasses only need to worry about adapting their
    formats to the base format, and not about implementing the logic for
    extracting the features.
    
    NOTE: When creating a SampleDao to store ExeSamples, you must use ExeSample
          as the sample type, not this class. Since this class does not
          re-include the feature annotations with the feature method
          implementations, the SampleDao will not be able to find all of the
          necessary feature methods.
    """
    
    ###########################################################################
    
    @abstractmethod
    def load_hex_view(self):
        """Load the hex representation of the executable's code section.
        
        The hex view should contain every instruction's address and machine
        code represented as hex digits. Each instruction should start with
        the address (8 digits) and then end with the instruction (32 digits).
        
        Whitespace is allowed between any of the digits, but it will simply
        be removed and only serves to degrade performance. 
        
        The total length of the hex view does not need to be perfectly 
        divisible by 40, as long as the last instruction is the only
        instruction that has fewer than 40 bytes.
        
        The hex view should be returned as a bytes string. Any other format
        is not guaranteed to work.
        
        Subclasses should only define this method, not use it. If a subclass
        wants the results of this method, call the hex_view method.
        """
        pass
    
    ###########################################################################
    
    @memoize
    def bytes(self):
        """Return a list of all bytes contained in the hex view.
        
        Bytes used to represent the addresses of instructions are not included
        due to their lack of usefulness.
        
        Each byte is represented by its decimal value. The special ?? byte is
        represented with a value of -1.
        """
            
        # Remove all spaces from the contents of the hex view.
        contents = self.hex_view()
        
        # Every two hex digits represents a single byte.
        byte_values = [-1 if contents[i:i+2] == b'??' 
                       else int(contents[i:i+2], 16) 
                       for i in range(0, len(contents), 2)]

        # The first four bytes of every 20 bytes contains an address, which
        # are not useful for analysis.
        byte_values = [byte_values[i] for i in range(len(byte_values))
                       if i % 20 >= 4]
            
        return byte_values
        
    @memoize
    def digits(self):
        """Return a list of all of the hex digits in the hex view.
        
        Digits used to represent addresses are included.
        
        Each hex digit is represented as an integer. The special ? digit is 
        represented with a value of -1.
        """
        
        digits = [-1 if digit == ord('?') 
                     else int(chr(digit), 16) 
                     for digit in self.hex_view()]
            
        return digits
        
    @memoize
    def entropies(self, window_size=10000):
        """Calculate the entropy values for each of the windows in the hex
        file if the window has the specified size.
        
        A list of all of the entropy values calculated for each window will
        be returned.
        """
        
        hex_bytes = self.bytes()
        
        # Ensure there are enough bytes for at least one window.
        if (len(hex_bytes) < window_size):
            raise ValueError(('The window size {0} exceeds the number ' +
                             'of bytes in the file: {1}')
                             .format(window_size, len(hex_bytes)))
                             
        # Retrieve the byte counts for the first window.
        window = hex_bytes[:window_size]
        
        byte_counts = {byte: 0 for byte in range(-1, 256)}
        for byte in window:
            byte_counts[byte] += 1
        
        # Calculate the entropy for the first window.
        current_entropy = entropy(byte_counts.values(), window_size)
        entropy_values = [current_entropy]
        
        # Add the entropy values for the rest of the windows.
        for i in range(1, len(hex_bytes) - window_size):
            
            # Determine which bytes were removed and added.
            removed_byte = hex_bytes[i-1]
            added_byte = hex_bytes[i+window_size]
            
            # If the added and removed bytes are not the same, the entropy 
            # needs to be adjusted.
            if (removed_byte != added_byte):
                
                removed_count = byte_counts[removed_byte]
                added_count = byte_counts[added_byte]
                                
                # Subtract out the old entropy values for the modified bytes.
                p = removed_count / window_size
                if (p > 0):
                    current_entropy += p * log(p, 2)
                                
                p = added_count / window_size
                if (p > 0):
                    current_entropy += p * log(p, 2)
                
                # Adjust the counts.
                removed_count -= 1
                added_count += 1
                
                # Add the new entropy values for the modified bytes.
                p = removed_count / window_size
                if (p > 0):
                    current_entropy -= p * log(p, 2)
                
                p = added_count / window_size
                if (p > 0):
                    current_entropy -= p * log(p, 2)
                    
                byte_counts[removed_byte] = removed_count
                byte_counts[added_byte] = added_count
                
            # Add the entropy value to the list.
            entropy_values.append(current_entropy)
            
        return entropy_values
        
    @memoize
    def hex_view(self):
        """Get the hex view of the executable. This will be returned as a bytes
        string.
        """
        
        # Remove all whitespace.
        return b''.join(self.load_hex_view().split())
        
    @memoize
    def image_array(self):
        """Create and return an image array containing a list of grayscale
        pixels generated from each hex digit in the file.
        """
                    
        # Retrieve all of the hex digits in the list.
        # NOTE: ? digits are interpreted as having a value of 0.
        digits = self.digits()
        imgarray = [0 if digit == -1 else digit for digit in digits]
        
        # Each line in a bytes file contains 40 digits. The last line of the
        # file, however, may contain less than 40 digits. In order to create
        # a non-jagged 2D array, we need to reduce the number of pixels to the
        # largest multiple of 40.
        lines = len(imgarray) // 40
        imgarray = imgarray[:lines*40]
        
        # Reshape the array of pixels into a 2D array containing 40 columns
        # and a number of rows equivalent to the number of rows in the file
        # (potentially minus 1 row).
        imgarray = np.reshape(imgarray, (lines, 40))        
            
        # Turn the list into a numpy array.
        imgarray = np.array(imgarray)
        
        return imgarray
        
    @memoize
    def strings(self):
        """Return a list of all strings in the file.
        
        Strings are determined by taking by converting all of the bytes in the
        file to their ASCII equivalent characters and separating the sequence
        of characters on "unreadable" characters. In ASCII, characters in the
        range of 32 - 127 are considered readable.
        """

        # Retrieve all of the bytes in the hex file.
        bytes = self.bytes()
        
        # Convert the hex values to decimal values.
        # NOTE: The ?? bytes are useless. Filter them out.
        ascii_values = [byte for byte in bytes if byte != -1]
        
        # The printable range for ASCII characters is 32 - 127. Replace
        # anything outside those bounds with a null to be filtered out.
        characters = [chr(value) if 32 <= value <= 127 else '\0' for value 
                      in ascii_values]
                      
        # Retrieve each string by splitting up sequences of characters by
        # null characters.
        strings = ''.join(characters)
        strings = [string for string in strings.split('\0') 
                   if string != '']
            
        return strings
        
    ###########################################################################
        
    def byte_count(self):
        return len(self.bytes())
        
    def entropy(self):
        return self.entropies(len(self.bytes()))[0]
        
    def entropy_stats(self, window_size=10000):
        
        # Retrieve the list of entropy values.
        entropy_values = self.entropies(window_size)
        
        # Calculate various statistics for the entropy values.
        features = [
            np.mean(entropy_values),
            np.var(entropy_values),
        ]
        
        # Percentiles 0 - 100
        features.extend(np.percentile(entropy_values, i) for i in range(101))
            
        return features
        
    def first_address(self):
        """Return the address of the first byte sequence in the sample's
        hex file.
        """
        
        # The first word in the hex file is the address of the first byte 
        # sequence.
        first_word = self.hex_view()[:8]
        
        # The address is a hexadecimal value. Convert it to decimal.
        return int(first_word, 16)
        
    def haralick_features(self):
    
        # Retrieve an image representation of the file.
        img = self.image_array()
        
        # Run Haralick features analysis on the image.
        features = mahotas.features.haralick(img)
        return list(features.flatten())
        
    def local_binary_patterns(self):
        
        # Retrieve an image representation of the file.
        img = self.image_array()
        
        # Find the 13 Local Binary Pattern features from the image.
        lbppoints = mahotas.features.lbp(img, 10, 10, ignore_zeros=False)
        
        return lbppoints.tolist()
        
    def one_gram_frequencies(self, *one_grams):
        
        # Default one_grams:
        if not one_grams:
            one_grams = range(256)
        
        # Validate one_grams:
        else:
            
            # Type check
            non_ints = sum(type(item) is not int for item in one_grams)
            if (non_ints > 0):
                raise TypeError('1-gram values must be integer values')
                
            # Range check
            invalid_ranges = sum(not 0 <= value <= 255 for value in one_grams)
            if (invalid_ranges > 0):
                raise ValueError('1-grams must be in the range 0 - 255 '
                                 + 'inclusive')
                                                                  
        # Every byte represents a one-gram.
        # NOTE: ?? bytes are ignored.
        file_one_grams = [byte for byte in self.bytes() if byte != -1]
            
        # Retrieve the counts for each one gram.
        counts = {one_gram: 0 for one_gram in one_grams}
        for one_gram in file_one_grams:
            if (one_gram in counts):
                counts[one_gram] += 1
                
        return [counts[one_gram] for one_gram in one_grams]
        
    def string_lengths(self, *bins):
        """Returns a histogram containing the count of all of the strings in
        each specified bin.
        
        The bins parameter should be a list of tuples containing 2 integers
        that define the range for each bin. The first number of each tuple
        should define the lower range (inclusive) and the second number should
        define the higher range (exclusive).
        
        On top of the specified bins, there will always be a bin countaining
        the count of all strings that didn't fall into any other bins. The
        count for this bin will be the last value in the returned list.
        """
        
        # Default bin_boundaries:
        if (not bins):
            bins = [(0, 10), (10, 30), (30, 60), (60, 90), (0, 100),
                    (100, 150), (150, 250), (250, 400), (400, 600), (600, 900),
                    (900, 1300), (1300, 2000), (2000, 3000), (3000, 6000), 
                    (6000, 150000)]
                    
        # If there were specific bin values passed, ensure they are structured
        # correctly.
        else:
            
            # Validate each bin.
            for bin in bins:
                
                # Ensure each item is a tuple.
                if (type(bin) is not tuple):
                    raise TypeError('Bins must be represented with tuples')
                    
                # Ensure each tuple has only two values.
                if (len(bin) != 2):
                    raise ValueError('Bin tuples must contain exactly 2 ints')
                    
                # Ensure both values are integers.
                if (type(bin[0]) is not int or type(bin[1]) is not int):
                    raise TypeError('Bin tuples must contain int values')
                    
        # Convert each bin to a range.
        bins = [range(bin[0], bin[1]) for bin in bins]
        
        # Retrieve all of the strings.
        strings = self.strings()
        
        # Categorize each string into a bin.
        # NOTE: A single string can be classified into multiple bins.
        counts = {bin: 0 for bin in bins}
        uncategorized = 0
        for string in strings:
            
            # Keep track if a string is categorized into at least one bin.
            categorized = False
            
            # Check if the string fits in each bin.
            for bin in bins:
                
                # Count the string if its length fits in the range of the bin.
                if len(string) in bin:
                    counts[bin] += 1
                    
                # Mark the bin as categorized.
                categorized = True
                
            # Check if the string was uncategorized.
            if (not categorized):
                uncategorized += 1
                
        # Return the count for every bin.
        counts = [counts[bin] for bin in bins]
        counts.append(uncategorized)
        
        return counts
        
    @feature('2-Gram Frequencies')
    def two_gram_frequencies(self):
        
        # Filter out all of the ?? bytes.
        sample_bytes = [byte for byte in self.bytes() if byte != -1]
             
        # A 2-gram consists of 2 bytes. Since each byte is already in decimal
        # format, we need to do a minor calculation to combine the two bytes.
        # The most significant byte can be viewed as one large value in the
        # 3rd digit's place in hex. This means we can simply multiply that
        # leftmost byte by 16^2 (256) and add it to the rightmost byte.
        file_two_grams = [sample_bytes[i] * 256 + sample_bytes[i+1] for i 
                                              in range(len(sample_bytes)-3)]
        
        # Count occurrences.
        two_grams = range(256**2)
        counts = {two_gram: 0 for two_gram in two_grams}
        for two_gram in file_two_grams:
            counts[two_gram] += 1

        return [counts[two_gram] for two_gram in two_grams]