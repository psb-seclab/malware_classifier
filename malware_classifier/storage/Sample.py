from inspect import getmembers

###############################################################################

def feature(feature_name):
    """Mark the specified method as a feature method. A feature method is a
    method that takes no arguments and returns either a single feature or a
    list of features. The feature_name should be a string specifying the
    desired name of the feature.
    
    This decorator only works with classes that inherit from the Sample class.
    """
    
    def mark_feature_method(method):
        
        # Give the method a special attribute that indicates the name of the
        # feature. This will be used to identify feature methods.
        method._feature_name = feature_name
        
        return method
        
    # Use the mark_feature_method function to mark functions.
    return mark_feature_method
    
###############################################################################

class Sample(object):
    """The Sample class is the base for a class that represents a specific
    type of sample. The Sample class provides utilities for marking methods
    as feature methods, which the SampleDao class can use to automatically
    generate, save, and load databases that hold the Sample's features.
    
    To mark a method as a feature method, import the "feature" decorator
    and use it on the requested method:
        
        class MySample(Sample):
            
            # ...
            
            @feature('Random')
            def random_feature(self):
                return random()
                
    The string passed in the decorator will be used for the column name used
    to hold the feature when a database is generated by the SampleDao class.
    """
    
    # Used to automatically generate sample ID's.
    _next_id = 1
    
    @classmethod
    def feature_methods(cls):
        """Retrieve a list of all of the class's feature methods.
        
        The returned list will contain tuples that contain the name of the
        feature (the string in the method's decorator) in the first slot and
        the actual method in the second slot.
        """
        
        # Get a list of all of the functions in the class.
        #
        # Note: The decorator will turn these methods into functions instead of
        #       methods. Hence, the predicate must be isfunction and not
        #       ismethod.
        functions = [function[1] for function 
                                 in getmembers(cls)]
        
        # Grab only the functions that contain the property inserted by the
        # feature decorator.
        decorated_functions = [(function._feature_name, function) 
                               for function in functions 
                               if hasattr(function, '_feature_name')]
                               
        return decorated_functions
        
    def __init__(self):
        """Initialize a new Sample object."""
        
        # Use the next id and increment it.
        self._id = Sample._next_id
        Sample._next_id += 1
        
    @property
    def features(self):
        """Get a full list of all features available in the class.
        
        This property appends the results of all of the feature methods
        into one list and returns the list. Before calling these methods, the
        optimize method will be called first to perform any optimizations the 
        implementing subclass may contain.
        """
        
        # Perform any optimizations that are available.
        self.optimize()
        
        # Retrieve the results of every feature method into one list.
        feature_list = []

        feature_methods = [f[1] for f in self.__class__.feature_methods()]
        for feature_method in feature_methods:
            
            # Evaluate the result of the method.
            feature = feature_method(self)
            
            # If the method only returned a single value, simply append it to
            # the list. If the method returned a full a list of features, add
            # all of the values individually.
            if (isinstance(feature, (list, tuple))):
                feature_list.extend(feature)
            
            else:
                feature_list.append(feature)
                
        return feature_list
        
    @property
    def identifier(self):
        """Get the identifier used to uniquely identify this sample.
        
        If this is not overridden, an incremented value will be used."""
        return self._id
    
    @property
    def label(self):
        """Get the label for the sample."""
        return None
            
    def optimize(self):
        """Performs any optimization that may improve performance when
        attempting to load all features from the sample at once.
        """
        pass
