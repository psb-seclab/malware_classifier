import csv
import errno
import os
import sqlite3

###############################################################################

def create_dirs(file_path):
    """Create any directories needed for the specified file.
    
    If the directories already exists for the file, this will do nothing.
    """
    
    # Retrieve the directory for the file.
    directory = os.path.dirname(file_path)
    
    # Ensure the directory does not exist.
    if (not directory or os.path.isdir(directory)):
        return
        
    # Create the directory.
    try:
        os.makedirs(directory)
        
    # NOTE: It is possible that a race condition can allow the directory to be
    #       created in between checking if the directory exists and attempting 
    #       to make the directory. If this happens, an error will be thrown.
    except OSError as e:
        
        # If the error was not due to the directory already existing, something
        # else happened.
        if (e.errno != errno.EEXIST):
            raise
            
###############################################################################
            
def load_features(feature_file_path):
    """Load the array of features from the specified feature file.
    
    A feature file should be formatted as a .csv (Comma Separated Value)
    file with only one row. Essentially, this means that the file should
    be formatted as a text file with every value separated by a comma.
    """
    
    # Ensure the file exists.
    if (not os.path.isfile(feature_file_path)):
        raise ValueError('Could not find feature file %s' 
                         % feature_file_path)
                         
    # Read first row of values.
    with open(feature_file_path) as file:
        feature_reader = csv.reader(file)
        return next(feature_reader)
            
###############################################################################

def save_features(features, feature_file_path):
    """Save the array of features in a csv file at the specified path.
    The .csv file extension will not be automatically added to the file
    name.
    
    If the directory where the file is to be held does not already exist, it
    will be created.
    """
    
    # Ensure the file's directory exists.
    create_dirs(feature_file_path)
    
    # Save the list of features to the file.
    with open(feature_file_path, 'w') as file:
        csv.writer(file).writerow(features)
            
###############################################################################

class SampleDao(object):
    """A SampleDao (Sample Database Access Object) provides access to a
    database that holds a variety of samples. The type of sample available
    depends on the type of sample passed into the constructor.
    
    SampleDao is abstract and should not be instantiated directly. Instead,
    a subclass should be made to adapt it to the appropriate sample type.
    """
    
    # The directory where all of the features are stored.
    _features_directory = r'Features/'
    
    def __init__(self, sample_type, database_file_name, table_name=None,
                 identifier_column_name='ID', label_column_name='Label'):
        """Initialize a new SampleDao for the specified sample type that
        accesses the database at the specified path. If the database does not
        already exist, it is created.
        
        Optional parameters:
            
            table_name - the name of the table in the database
            identifier_column_name - the name of the primary key colmumn
            label_column_name - the name of the column containing labels
            
        """
        
        # Set the sample type.
        self._sample_type = sample_type
        
        # Set the column names.
        self._identifier_column_name = identifier_column_name
        self._label_column_name      = label_column_name
        
        # Set the table name.
        self._table_name = table_name or '{0}s'.format(sample_type.__name__)
        
        # Ensure the directory for the database exists.
        create_dirs(database_file_name)
        
        # Create the connection for the database.
        #
        # Note: If the database file doesn't exist yet, this will create it.
        self._connection = sqlite3.connect(database_file_name)
        
        # Construct the query to create the table to hold all of the samples.       
        feature_names = [feature[0] for feature 
                                    in sample_type.feature_methods()]
        feature_query = ','.join('[%s] TEXT' % feature for feature 
                                                       in feature_names)
        
        query  = 'CREATE TABLE IF NOT EXISTS %s (' % self.table_name
        query += '%s TEXT PRIMARY KEY,' % self.identifier_column_name
        query += '%s TEXT' % self.label_column_name
        if (feature_query):
            query += ',{0}'.format(feature_query)
        query += ')'
                
        self._connection.execute(query)
        
    def __exit__(self):
        """Close the connection to the databse.
        
        This method provides compatibility with the "with" keyword.
        """
        self._connection.close()
        
    @property
    def identifier_column_name(self):
        """Get the name of the column used for the primary key column in the
        database.
        """
        return self._identifier_column_name
    
    @property
    def label_column_name(self):
        """Get the name of the column used for the label in the database."""
        return self._label_column_name
        
    @property
    def sample_type(self):
        """Get the sample class type of the samples stored in the database
        accessed by this 
        """
        return self._sample_type
    
    @property
    def table_name(self):
        """Get the name of the table created in the database to hold the
        samples.
        
        By default, this returns the name of the sample type with an 's'
        appended to the end.
        """
        return self._table_name
        
    def add_sample(self, sample):
        """Add the specified sample to the database."""
        
        # Ensure the sample is of the correct type.
        if (not isinstance(sample, self.sample_type)):
            raise TypeError("Sample is of the incorrect type")
            
        # Retrieve the id, label, and set of features.
        id = sample.identifier
        label = sample.label
        
        features = []
        for feature_name, feature_method in self.sample_type.feature_methods():
            
            # Execute the method for the sample and retrieve the feature
            # value.
            value = feature_method(sample)
            
            # If the value is a list of features instead of a single value,
            # save the list to a csv file and insert the path to the file
            # in the database in place of a value.
            if (isinstance(value, (list, tuple))):
                
                # The file directory should have be:
                #
                #     {Features Directory}/{Table Name}/{Feature Name}/{Sample}
                #
                file_name = '%s.csv' % id
                
                file_path = os.path.join(self._features_directory, 
                                         self.table_name, feature_name, 
                                         file_name)
                
                # Save the features to the file and then set the file path as 
                # the value to be written.
                save_features(value, file_path)
                value = file_path
            
            # Add the feature
            features.append(value)

        # Construct the query to insert the record in the database.
        feature_params = ','.join('?' * len(features))
        query = 'INSERT INTO {0} VALUES(?, ?, {1})'.format(self.table_name, 
                                                           feature_params)
          
        print(query)
        self._connection.execute(query, [id, label] + features)
        self._connection.commit()
        
    def feature_matrix(self, include_labels=False):
        """Retrieve a matrix containing all of the features (columns) for all
        of the samples (rows) in the database.
        
        The feature matrix is an m x n 2D array where m is the number of
        samples in the database and n is the number of columns in the database.
        
        Setting include_labels to true will include the labls column at the
        end.
        """
        
        # Construct a query to grab all of the feature columns (and optionally
        # the label column) from the database.
        feature_methods = self.sample_type.feature_methods()
        columns = [method[0] for method in feature_methods]

        if (include_labels):
            columns += self.label_column_name
        
        columns_string = ','.join('[%s]' % column for column in columns)
        query = 'SELECT {0} FROM {1}'.format(columns_string, self.table_name)
        
        cursor = self._connection.cursor()
        cursor.execute(query)
        
        # If a feature column holds multiple features, the value will be a 
        # string containing the path to a csv file that holds the list of
        # values. Otherwise, it will simply be a numerical value.
        feature_matrix = []
        for record in cursor:
            
            # Construct a list of all of the features in the cursor.
            features = []
            feature_matrix.append(features)
            
            for value in record:
                
                # Try to parse the value as a number.
                try:
                    features.append(int(value))
                    
                # If the value is not a number, it must be a path to a csv
                # file.
                except:
                    features.extend(load_features(value))
                    
        return feature_matrix
    
    def identifiers(self):
        """Retrieve a list of all of the identifiers for all of the samples in
        the database. All identifiers are guaranteed to uniquely identify a
        sample in the database.
        """
        
        # Construct query to grab identifier from table       
        query = 'SELECT {0} FROM {1}'.format(self.identifier_column_name,
                                             self.table_name)
        
        cursor = self._connection.cursor()
        cursor.execute(query)
        
        # The cursor is constructed as a list of records, with each record
        # holding a list of columns. In this case, there is only one column
        # in each record. Therefore, the cursor can simply be flattened into 
        # a regular list.
        return [str(label) for record in cursor for label in record]

    def labels(self):
        """Retrieve a dictionary of all of the labels associated with each
        sample. The keys for the dictionary will be the identifiers for each
        of the samples.
        """
        
        # Construct a query to grab the identifier and label from the table.        
        query = 'SELECT {0}, {1} FROM {2}'.format(self.identifier_column_name,
                                                  self.label_column_name,
                                                  self.table_name)
        
        cursor = self._connection.cursor()
        cursor.execute(query)
        
        # The ID is in the first column and the label is in the second column.
        # Use the ID as the key and the label as the value.
        return {str(record[0]): int(record[1]) if record[1] else None 
                                               for record in cursor}