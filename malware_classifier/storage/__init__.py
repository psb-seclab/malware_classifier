__all__ = ['create_dirs', 'exe', 'SampleDao']

###############################################################################

import csv
import errno
import os
import sqlite3

###############################################################################

def create_dirs(file_path):
    """Create any directories needed for the specified file.
    
    If the directories already exists for the file, this will do nothing.
    """
    
    # Retrieve the directory for the file.
    directory = os.path.dirname(file_path)
    
    # Ensure the directory does not exist.
    if (not directory or os.path.isdir(directory)):
        return
        
    # Create the directory.
    try:
        os.makedirs(directory)
        
    # NOTE: It is possible that a race condition can allow the directory to be
    #       created in between checking if the directory exists and attempting 
    #       to make the directory. If this happens, an error will be thrown.
    except OSError as e:
        
        # If the error was not due to the directory already existing, something
        # else happened.
        if (e.errno != errno.EEXIST):
            raise

###############################################################################

class SampleDao(object):
    """A SampleDao (Sample Database Access Object) provides access to a Sample
    database. The type of samples available in the database depends on the
    type of subclass.
    
    SampleDao is simply a base class that provides basic features for more
    specific Dao classes to extend. A subclass of this class must implement
    the following attributes:
    
        table_name {static string} - the name of the table that should be
                                     accessed in the database
                                
        identifier_column {static string} - the name of the column that
                                            contains the primary key
                                            
        label_column {static string} - the name of the column that contains the
                                       labels
                                            
        feature_columns {static array of strings} - the names of all of the
                                                    columns that contain the
                                                    features in the database
                                                    
    This class encapsulates a connection to a database. Subclasses can utilize
    this connection using the _connection field.
    """
    
    def __init__(self, database_file_path):
        """Initialize a new SampleDao that accesses the database pointed to
        by the specified file path.
        
        If the database file does not already exist, it will be created. If
        the database does not already contain a compatible table, it will be
        generated.
        """
        
        # Ensure the directory for the file exists.
        create_dirs(database_file_path)
            
        # Create Connection
        # NOTE: This will create the file if it doesn't already exist. 
        self._connection = sqlite3.connect(database_file_path)
        
        # Construct the samples table if it doesn't already exist.
        table_query = 'CREATE TABLE IF NOT EXISTS %s (' % self.table_name
        table_query += '%s TEXT PRIMARY KEY,' % self.identifier_column
        table_query += '%s TEXT,' % self.label_column
        table_query += ','.join('[%s] TEXT' % column for column 
                                in self.feature_columns)
        table_query += ')'
        
        self._connection.execute(table_query)
        
    def __exit__(self, exception_type, exception_value, traceback):
        """Close the connection to the encapsulated database.
        
        This method provides compatibility with the 'with' keyword.
        """
        self._connection.close()
        
    @property
    def feature_columns(self):
        """The list of column names for the features in the database.
        
        A feature column should have the TEXT data type. Values in the column
        should contain a path to the feature file relative to the directory
        of the database.
        """
        raise NotImplementedError('SampleDao cannot be instantiated directly')
        
    @property
    def identifier_column(self):
        """The name of the column in the table that contains the primary key
        for the sample.
        """
        raise NotImplementedError('SampleDao cannot be instantiated directly')
        
    @property
    def label_column(self):
        """The name of the column in the table that contains the label for the
        sample.
        """
        raise NotImplementedError('SampleDao cannot be instantiated directly')
        
    @property
    def table_name(self):
        """The name of the table in the database that the samples should be
        retrieved from.
        """
        raise NotImplementedError('SampleDao cannot be instantiated directly')
        
    def feature_matrix(self, labels=False):
        """Retrieve a matrix containing all of the features for all of the
        samples in the database.
        
        The feature matrix is an m x n 2D array where m is the number of
        records in the database and n is the number of features each sample
        contains.
        
        Each row in the matrix represents a sample and each column represents
        a feature.
        
        Set labels equal to true in order to add the labels to the feature
        matrix.
        """
        
        # Select the feature columns for all of the records from the database.
        features_query = 'SELECT '
        features_query += ','.join('[%s]' % column for column 
                                   in self.feature_columns)
        features_query += ' FROM %s' % self.table_name
        
        cursor = self._connection.cursor()
        cursor.execute(features_query)
                
        # Load all of the files pointed to by each column.
        features = []
        for sample, label in zip(cursor, self.labels()):
            sample_features = []
            
            # Append the features from each category.
            for category in sample:
                sample_features += self.load_features(category)
                
            # Append the label if requested.
            if (labels):
                features.append(label)
            
        return features
        
    def identifiers(self):
        """Retrieve an array containin the identifiers for all of the samples
        in the connected database.
        
        Each identifier in the list will correspond with the sample in the 
        feature matrix whose row value is the same as the identifier's column
        value.
        """
        
        # Select the identifier column for all of the records in the database.
        identifier_label = 'SELECT {0} FROM {1}'.format(self.identifier_column,
                                                        self.table_name)
        
        cursor = self._connection.cursor()
        cursor.execute(identifier_label)
        
        return [identifier for record in cursor for identifier in record]

    def insert(self, identifier, label, *features):
        """Insert a new sample into the database.
        
        The identifier should be a value to uniquely identify the sample.
        
        The label should be the label for the sample. If the sample has no
        label or if it is unknown, 'NULL' can be used.
        
        The number of supplied features must match the number of feature
        columns defined.
        """
        
        # Ensure the number of features and feature columns match.
        if (len(features) != len(self.feature_columns)):
            raise ValueError('The number of features does not match the ' +
                             'number of feature columns')
            
        # Construct the query.
        args = ','.join('?' for i in len(features))
        query = 'INSERT INTO {0} VALUES ({1})'.format(self.table_name, args)
        
        self._connection.execute(query, features)
                                                 
    def labels(self):
        """Retrieve an array containing the labels for all of the samples in
        the connected database.
        
        Each label in the list will correspond with the sample in the feature
        matrix whose row value is the same as the label's column value.
        """
        
        # Select the label column for all of the records in the database.
        labels_query = 'SELECT {0} FROM {1}'.format(self.label_column, 
                                                    self.table_name)
                                                    
        cursor = self._connection.cursor()
        cursor.execute(labels_query)
        
        return [label for record in cursor for label in record]
        
    def load_features(self, feature_file_path):
        """Load the array of features from the specified feature file.
        
        A feature file should be formatted as a .csv (Comma Separated Value)
        file with only one row. Essentially, this means that the file should
        be formatted as a text file with every value separated by a comma.
        """
        
        # Ensure the file exists.
        if (not os.path.isfile(feature_file_path)):
            raise ValueError('Could not find feature file %s' 
                             % feature_file_path)
                             
        # Read first row of values.
        with open(feature_file_path) as file:
            feature_reader = csv.reader(file)
            return next(feature_reader)
            